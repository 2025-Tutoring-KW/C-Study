# μ—°κ²° λ¦¬μ¤νΈ
μ—°κ²°λ¦¬μ¤νΈλ” λ°μ΄ν„°λ¥Ό λ…Έλ“(Node) λΌλ” λ‹¨μ„λ΅ μ €μ¥ν•κ³ ,  
κ° λ…Έλ“κ°€ λ‹¤μ λ…Έλ“λ¥Ό κ°€λ¦¬ν‚¤λ” λ°©μ‹μΌλ΅ μ—°κ²°λ μ„ ν• **μ €μμ¤€ μλ£κµ¬μ΅°**(linear data structure).
## μ—°κ²° λ¦¬μ¤νΈμ κµ¬μ„± μ”μ†
![μ—°κ²°λ¦¬μ¤νΈ](https://raw.githubusercontent.com/2025-Tutoring-KW/image/refs/heads/main/%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8.png)

## head, tail
μ—°κ²° λ¦¬μ¤νΈμ μ²«λ²μ§Έ λ…Έλ“μ™€ λ§μ§€λ§‰ λ…Έλ“λ¥Ό κ°€λ¦¬ν‚¤λ” ν¬μΈν„°

### node κµ¬μ„± μ”μ†
μ—°κ²°λ¦¬μ¤νΈμ κ° λ…Έλ“(Node) λ” λ³΄ν†µ λ‘ λ¶€λ¶„μΌλ΅ κµ¬μ„±λ¨.

λ°μ΄ν„°(data): μ €μ¥ν•  κ°’

ν¬μΈν„°(next): λ‹¤μ λ…Έλ“λ¥Ό κ°€λ¦¬ν‚¤λ” μ°Έμ΅°

![μ—°κ²°λ¦¬μ¤νΈ_κµ¬μ΅°](https://raw.githubusercontent.com/2025-Tutoring-KW/image/refs/heads/main/%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%99%80_%EB%B0%B0%EC%97%B4.png)
```c
typedef struct Node{
    int data;   // μ €μ¥ν•  κ°’
    struct Node* next; // μκΈ°μ°Έμ΅° κµ¬μ΅°μ²΄λ¥Ό μ΄μ©ν•΄ μκΈ° λ‹¤μ λ…Έλ“λ¥Ό κ°€λ¦¬ν‚¤λ” λ…Έλ“ μ£Όμ†λ¥Ό μ €μ¥.
}Node;

typedef struct {
    Node* head;  // μ²« λ²μ§Έ λ…Έλ“λ¥Ό κ°€λ¦¬ν‚¤λ” ν¬μΈν„°
    Node* tail;  // λ§μ§€λ§‰ λ…Έλ“λ¥Ό κ°€λ¦¬ν‚¤λ” ν¬μΈν„°
    int count;   // λ¦¬μ¤νΈμ λ…Έλ“ μλ¥Ό μ €μ¥ν•λ” λ³€μ
}List;

```


## μλ£κµ¬μ΅°μ μΆ…λ¥

### μ €μμ¤€ μλ£κµ¬μ΅°
**1. μ •μ / μ‹¤μ / λ¬Έμ (κΈ°λ³Έ λ°μ΄ν„° νƒ€μ…)**
  int, float, char λ“±

  ν”„λ΅κ·Έλλ° μ–Έμ–΄μ—μ„ μ κ³µν•λ” κ°€μ¥ λ‹¨μν• λ°μ΄ν„° λ‹¨μ„

**2. λ°°μ—΄ (Array)**  
  κ³ μ • ν¬κΈ°μ μ—°μ†λ λ©”λ¨λ¦¬ λΈ”λ΅

  μΈλ±μ¤λ¥Ό ν†µν• λΉ λ¥Έ μ ‘κ·Ό κ°€λ¥

  κ°€μ¥ λ„λ¦¬ μ“°μ΄λ” μ €μμ¤€ κµ¬μ΅°

**3. μ—°κ²°λ¦¬μ¤νΈ (Linked List)**  
  λ…Έλ“λ“¤μ΄ ν¬μΈν„°λ΅ μ—°κ²°λ κµ¬μ΅°

  ν¬κΈ° λ™μ  μ΅°μ  κ°€λ¥

  λ°°μ—΄κ³Ό λ‹¬λ¦¬ λ©”λ¨λ¦¬ μ—°μ†μ„±μ΄ ν•„μ” μ—†μ

**4. ν¬μΈν„° (Pointer) / μ°Έμ΅° (Reference)**  
  λ©”λ¨λ¦¬ μ£Όμ†λ¥Ό μ €μ¥ν•λ” λ°μ΄ν„° νƒ€μ…

  μ—°κ²°λ¦¬μ¤νΈ, νΈλ¦¬, κ·Έλν”„ λ“±μ„ κµ¬ν„ν•  λ• ν•µμ‹¬

**5. λ μ½”λ“ (Record) / κµ¬μ΅°μ²΄ (Struct)**  
  μ—¬λ¬ λ°μ΄ν„° νƒ€μ…μ„ ν•λ‚λ΅ λ¬¶μ€ λ³µν•© λ°μ΄ν„° κµ¬μ΅°

  μ: C μ–Έμ–΄μ struct, Pythonμ class

**6. λΉ„νΈ λ²΅ν„° / λΉ„νΈ λ°°μ—΄ (Bit Vector / Bit Array)**  
  κ°κ°μ λΉ„νΈλ¥Ό ν•λ‚μ κ°’μΌλ΅ κ°„μ£Όν•μ—¬ μ €μ¥

  κ³µκ°„μ„ λ§¤μ° ν¨μ¨μ μΌλ΅ μ‚¬μ©ν•λ” κµ¬μ΅°

  λΉ„νΈ λ²΅ν„°/λΉ„νΈ λ°°μ—΄ (Bit Vector / Bit Array)

### κ³ μμ¤€ μλ£κµ¬μ΅°

**μ¤νƒ (Stack)**

**ν (Queue)**

**λ± (Deque)**

**νΈλ¦¬ (Tree)**

**μ΄μ§„νΈλ¦¬**

**μ΄μ§„ νƒμƒ‰ νΈλ¦¬(BST)**

**ν™(Heap)**

**νΈλΌμ΄(Trie)**

**κ·Έλν”„ (Graph)**

**ν•΄μ‹ ν…μ΄λΈ” (Hash Table)**

**ν™ (Heap)**

**νΈλΌμ΄ (Trie)**

## μ—°κ²°λ¦¬μ¤νΈ μ½”λ“
![μ—°κ²°λ¦¬μ¤νΈ](https://raw.githubusercontent.com/2025-Tutoring-KW/image/refs/heads/main/%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8.png)

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

typedef struct Node{
    int data;   // μ €μ¥ν•  κ°’
    struct Node* next; // μκΈ°μ°Έμ΅° κµ¬μ΅°μ²΄λ¥Ό μ΄μ©ν•΄ μκΈ° λ‹¤μ λ…Έλ“λ¥Ό κ°€λ¦¬ν‚¤λ” λ…Έλ“ μ£Όμ†λ¥Ό μ €μ¥.
}Node;

typedef struct {
    Node* head;  // μ²« λ²μ§Έ λ…Έλ“λ¥Ό κ°€λ¦¬ν‚¤λ” ν¬μΈν„°
    Node* tail;  // λ§μ§€λ§‰ λ…Έλ“λ¥Ό κ°€λ¦¬ν‚¤λ” ν¬μΈν„°
    int count;   // λ¦¬μ¤νΈμ λ…Έλ“ μλ¥Ό μ €μ¥ν•λ” λ³€μ
}List;

void insert(List* list, int data);
int delete(List* list, int target);
void print(List* list);
int main() {
    List list;
    list.head = NULL;
    list.tail = NULL;
    list.count = 0;
    while (1) {
        char command[101];
        printf("Enter a command (insert or delete or print or exit) : ");
        scanf("%s", command);
        if (strcmp(command,"insert") == 0) {
            int data;
            printf("Enter a data : ");
            scanf("%d", &data);
            insert(&list, data);
        }
        else if (strcmp(command, "delete") == 0) {
            int target;
            printf("Enter a target : ");
            scanf("%d", &target);
            delete(&list, target);
        }
        else if (strcmp(command, "print") == 0) {
            print(&list);
        }
        else if (strcmp(command, "exit") == 0) {
            break;
        }
        else {
            printf("Error : Wrong Command.\n");
        }
    }
    Node* current = list.head;
    list.head = NULL;
    list.tail = NULL;
    list.count = 0;
    while (current!=NULL) {
        Node* tmp = current;
        current = current->next;
        free(tmp);
    }
    printf("exit program\n");
    return 0;
}
void insert(List* list, int data) {
    Node* node = (Node*)malloc(sizeof(Node));
    node->data = data;
    node->next = NULL;
    if (list->head == NULL) {
        list->head = node;
    }
    else {
        list->tail->next = node;
    }
    list->tail = node;
    list->count++;
}
int delete(List* list, int target) {
    Node* current = list->head;
    if (current->data == target) {
        if (list->head == list->tail) {
            list->head = NULL;
            list->tail = NULL;
        }
        else {
            list->head = list->head->next;
        }
        free(current);
        list->count--;
        return 0;
    }
    else {
        while (current != NULL) {
            if (current->data == target) {
                Node* tmp = list->head;
                while (tmp->next->data != target) {
                    tmp = tmp->next;
                }
                tmp->next = current->next;
                if (current == list->tail) {
                    list->tail = tmp;
                }
                free(current);
                list->count--;
                return 0;
            }
            current = current->next;
        }
        printf("no exist target.\n");
    }
}
void print(List* list) {
    if (list->count != 0) {
        printf("{ ");
        Node* current = list->head;
        while (current != NULL) {
            printf("%d", current->data);
            if (current->next != NULL) {
                printf(", ");
            }
            current = current->next;
        }
        printf("}, head : %d, tail : %d\n", list->head->data, list->tail->data);
    }
    else {
        printf("No exit list\n");
    }
}
```
# μ—°κ²°λ¦¬μ¤νΈμ™€ λ°°μ—΄μ μ¥λ‹¨μ 
β… **λ°°μ—΄ (Array)**  
π“ μ¥μ   	  
β… λΉ λ¥Έ μ ‘κ·Ό μ†λ„	μΈλ±μ¤λ΅ μ ‘κ·Ό κ°€λ¥ β†’ arr[0], arr[5] λ“± O(1)  
β… λ©”λ¨λ¦¬ μ‚¬μ© ν¨μ¨μ 	μ—°μ†λ λ©”λ¨λ¦¬ κ³µκ°„μ— μ €μ¥λλ―€λ΅ μΊμ‹ μΉν™”μ   
β… κµ¬ν„μ΄ κ°„λ‹¨	κµ¬μ΅°κ°€ λ‹¨μν•΄μ„ μ‚¬μ©κ³Ό κµ¬ν„μ΄ μ‰¬μ›€  

β λ‹¨μ    
β ν¬κΈ° κ³ μ •	μ„ μ–Έν•  λ• ν¬κΈ°λ¥Ό λ―Έλ¦¬ μ •ν•΄μ•Ό ν•¨ (int arr[100];)  
β μ¤‘κ°„ μ‚½μ…/μ‚­μ  λλ¦Ό	μ”μ†λ¥Ό ν• μΉΈμ”© λ°€κ±°λ‚ λ‹Ήκ²¨μ•Ό ν•¨ β†’ O(n)  
β λ©”λ¨λ¦¬ λ‚­λΉ„ κ°€λ¥	μ‚¬μ©ν•μ§€ μ•λ” κ³µκ°„μ΄ μƒκΈ°κ±°λ‚, μ΄κ³Όν•  μλ„ μμ  

β… **μ—°κ²°λ¦¬μ¤νΈ (Linked List)**    
π“ μ¥μ   	  
β… ν¬κΈ° μ ν• μ—†μ	ν•„μ”ν•  λ•λ§λ‹¤ λ™μ μΌλ΅ λ…Έλ“λ¥Ό μ¶”κ°€/μ‚­μ  κ°€λ¥  
β… μ‚½μ…/μ‚­μ κ°€ λΉ λ¦„	μ•μ΄λ‚ μ¤‘κ°„μ—μ„ λ…Έλ“λ¥Ό μ¶”κ°€/μ‚­μ ν•  λ• O(1) κ°€λ¥ (ν¬μΈν„°λ§ μ΅°μ •)  
β… λ©”λ¨λ¦¬ ν¨μ¨μ 	ν•„μ”ν• λ§νΌλ§ λ©”λ¨λ¦¬ ν• λ‹Ή  

β λ‹¨μ   
β λλ¦° μ ‘κ·Ό μ†λ„	μΈλ±μ¤ μ ‘κ·Όμ΄ λ¶κ°€λ¥ β†’ μμ°¨ νƒμƒ‰ O(n)  
β ν¬μΈν„° κ΄€λ¦¬ λ³µμ΅	κ° λ…Έλ“κ°€ λ‹¤μ λ…Έλ“λ¥Ό κ°€λ¦¬ν‚¤λ” ν¬μΈν„°λ¥Ό κ°€μ§ β†’ μ‹¤μν•κΈ° μ‰¬μ›€  
β λ©”λ¨λ¦¬ μ¶”κ°€ μ†λΉ„	κ° λ…Έλ“λ§λ‹¤ λ°μ΄ν„° + ν¬μΈν„° κ³µκ°„ ν•„μ”  
β λ©”λ¨λ¦¬ μ¤λ²„ν—¤λ“λ΅ μΈν• μ¶”κ°€ λ©”λ¨λ¦¬ μ†λΉ„(head, current, tail λ“±λ“±)

# μ—°κ²°λ¦¬μ¤νΈλ¥Ό μ‚¬μ©ν•λ” μ΄μ 
μ—„μ²­λ‚ μμ λ„ (μ›ν•λ” κµ¬μ΅°λ¥Ό λ§λ“¤ μ μμ)  
![μ—°κ²°λ¦¬μ¤νΈ_ν™μ©](https://raw.githubusercontent.com/2025-Tutoring-KW/image/refs/heads/main/%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8_%ED%99%9C%EC%9A%A9.png)
****μ‚½μ…κ³Ό μ‚­μ  μ„μΉκ°€ κ³ μ •λμ–΄μλ” μλ£κµ¬μ΅°μ—μ„ λ§¤μ° κ°•λ ¥**** ex) μ¤νƒ(Stack), ν(Queque) λ“±λ“±  

# λ°°μ—΄λ΅ μλ£κµ¬μ΅°λ¥Ό κµ¬ν„ν•κΈ° μ λ¦¬ν•  λ•.
λ°μ΄ν„°μ μ‚­μ κ°€ μ—†λ” κ²½μ°μ—λ” λ°°μ—΄λ΅ μλ£ κµ¬μ΅°λ¥Ό λ§λ“¤κΈ° μΆ‹μ.



# μ‹¤μµμμ 
## 1. μ–‘λ°©ν–¥ μ—°κ²°λ¦¬μ¤νΈ κµ¬ν„  
![μ–‘λ°©ν–¥_μ—°κ²°λ¦¬μ¤νΈ](https://raw.githubusercontent.com/2025-Tutoring-KW/image/refs/heads/main/%EC%96%91%EB%B0%A9%ED%96%A5_%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8.png)

## 2. λ°±μ¤€ 10828, 10845 (μ¤νƒ, ν κµ¬ν„ λ¬Έμ )


## λ°±μ¤€ λ¬Έμ  λ‹µμ§€
λ„λ¬΄ λ§‰νλ‹¤ μ‹¶μ„ λ• λ³΄μ„Έμ” λ‚¨λ° γ„΄γ„΄.  
[μλ£κµ¬μ΅°_μλ£](https://eungulife.tistory.com/261)
